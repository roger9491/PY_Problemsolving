'''
題目:
    給一串 長度 n 的字串 s，由 0 or 1組成，
    我們想要消除 字串s 使其長度為0

    我們能做的處裡 有兩個連續步驟 (做完(1)接者做(2))
    (1)
        選擇一個任意位置 i 的字串進行刪除。
    (2)
        把字串最前面 相同字符 刪除
        ex: s = 0011110 ->(2) -> 11110
        ex: s = 10010 -> (2) -> 0010 
        換句話說就是刪除 前綴 同字符 
    所以 有個例子
    s = 111010  n = 6
    你在做一次處裡的時候 會有6個選擇
    i = 1   s -> (1) -> 11010 -> (2) -> 010
    i = 2   s -> (1) -> 11010 -> (2) -> 010
    i = 3   s -> (1) -> 11010 -> (2) -> 010
    i = 4   s -> (1) -> 11110 -> (2) -> 0
    i = 5   s -> (1) -> 11100 -> (2) -> 00
    i = 6   s -> (1) -> 11101 -> (2) -> 01

    你的目標 就是 一直 做 (1)(2) 步驟 直到 刪完 s，
    但是 我們要求的是 最大步驟數量。
    (上面的例子 可以看出 每個不同選擇 會有不同的步驟數)
輸入格式:
    第一行 t 代表 測資數量 (1≤t≤1000) 
    每個 測資 第一行 n 字串長度  (1≤n≤2*10**5)
             第二行 s 字串
輸出格式:
    輸出最大步驟數
    
example
input:
5
6
111010
1
0
1
1
2
11
6
101010
output:
5
6
111010
1
0
1
1
2
11
6
101010
說明:
    第一筆測資 n = 6 s = 111010 答案是 3
    可能的步驟是: 
    一步: (1)i = 2 11010 (2) 010
    二步: (1)i = 3 01 (2) 1
    二步: (1)i = 1 
解法:
    greedy + 指針
   
詳解:
    我們貪心 選擇 的 i 最好是選擇 前綴 裡的字符，
    但 前綴同字符 最好長度 要 >= 2 
    ex: 11010 -> 1010    
    ex: 011010 -> 110101 -> 0101(若這樣選擇 1會被消耗 會消耗太多)
                        -> 010101 -> 10101(正確)
    
    為了降低複雜度 我先把 連續塊 找出來
    ex n=6 s=111010 連續塊 : string = [3,1,1,1]
    不同位置 代表不一樣的字符
    這時候 我們就 照我們貪心 策略，
    再優化 使用雙指針
    i 代表 要刪除 前綴的位置 (首塊位置)
    j      選擇 刪除一個字符 的位置

    若 string[j] >= 2 ，代表 可以選擇
                否       j += 1 往後面找    


'''
t = int(input())    #測資數量
for i in range(t):
    n = int(input())    #字串長度
    s = input()     #字串

    string = []     #儲存連續塊的長度
    stack = []      #計算 連續塊的長度 用的堆疊
    for i in range(n):
        if not stack:   #空堆疊 加入字串
            stack.append(s[i])
        else:
            if s[i] == stack[-1]:   
                stack.append(s[i])
            else:
                string.append(len(stack))
                stack = [s[i]]
    if stack:           #當 堆疊有東西 表示 還沒儲存 長度
        string.append(len(stack))
    
    i = 0   #首塊 位置
    j = 0   #搜尋位置
    c = 0   #步驟數
    n = len(string) #連續塊的 數量
    flag = False
    # print(string)
    while i < n:    #起始位置 要小於 n
        if not flag:    #flag 用來判斷 還有沒有 長度 為 >= 2 的塊
            if string[j] >= 2:  #判斷過 做一次 處裡  
                if i == j:  #表示 要消除 的是首塊
                    string[j] = 0
                else:
                    string[j] -= 1
                i += 1
                c += 1  
            else:
                j += 1
            if j == n:      # 表示 沒有一塊長度 >= 2的塊了
                flag = True
        else:
            # print(c,i,j)
            a = (n-1 - i) + 1       #一次計算完 步驟數
            c += a // 2
            if a % 2 != 0:
                c += 1
            break
    print(c)


