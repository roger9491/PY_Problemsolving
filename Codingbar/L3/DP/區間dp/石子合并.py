'''
https://www.acwing.com/problem/content/description/284/
合併相鄰的兩堆，代表這兩堆必須是最小代價
換句話說，每一堆都代表著不同的區間。

狀態定義:
    dp[i][j]: 區間 i ~ j的合併最小代價
ex 4 8 ， 因為是 相鄰兩堆 做合併，所以中間點不確定 要找到最小的
狀態轉移
    dp[i][j] = min((dp[i][k]+dp[k+1][j]),....)(k = i ~ j-1) + 
4
1 3 5 2
ex 求合併最小代價
按照題目所說 最後的答案必是 兩堆石頭相鄰合併，所以 求到最後 必是兩堆
按照這個思想，有可能是 1. 1 || 3 5 2    2. 1 3 || 5 2   3. 1 3 5 || 2
那這樣 就會變成 求 較小的狀態
3 5 2 , 1 3 5 ,這兩堆 要先求出 最小代價 已上的式子才能做比較

換句話說 我們必須要先求出區間長度較小的，在求出區間長度大的
譬如說 3 5 2 區間 1 3， 那一樣 可能是 3 || 5 2, 3 5 || 2
得證。
(1)迭代區間長度 由小到大
(2)迭代 出要求的區間a
(3)區間a為 兩兩石堆合併 所以要迭代 斷點 k

ex
4
1 3 5 2

00 11 22 33 0
01 12 23    1
02 13   2
03  3



4
1 3 5 2
dp[0][1] = min(dp[0][0]+dp[1][1])
         = 2 + 6 = 8
1 + 3 = 4

1 3 5               1 + 16
dp[0][2] = min((dp[0][0]+dp[1][2]),(dp[0][1]+dp[2][2]))
(1)
1 3 = 4
4 5 
4 5 = 9
ans: 13
(2)
3 5 = 8
1 8 
1 8 = 9
ans: 17

3 5 2
8
18

7
10
17




00 11 22 33 0
0123
01 12 23 1
012
02 13 2
01
0 3

(dp[0][0]+dp[1][3])
dp[0][0] = 1 
dp[1][3] = 3 5 2 的合併最小代價
(dp[1][2]+dp[3][3])
3 5 2
3 5 = 8
8 2 = 10
8 + 10 = 18
所以 dp[1][2] = 
dp[1][1]+dp[2][2] = 3 + 5 = 8
dp[1][3] = min((dp[1][1]+dp[2][3]),(dp[1][2]+dp[3][3]))
(dp[1][1]+dp[2][3]) => 3 + 7
(dp[1][2]+dp[3][3]) => 8 + 2


dp[0][3] = min((dp[0][0]+dp[1][3]),(dp[0][1]+dp[2][3]),(dp[0][2]+dp[3][3]))

22
'''



n = int(input())
a = list(map(int, input().split()))
dp = [[10**9]*(n) for i in range(n)]

sum_pre = [0]
'''
4
1 3 5 2
1 4 
'''
t = 0
for i in range(n):
    t += a[i]
    sum_pre.append(t)
# print(sum_pre)

for length in range(n):
    for i in range(n-length):
        j = i + length
        if i == j:
            dp[i][j] = 0
        else:
            for k in range(i,j):
                dp[i][j] = min(dp[i][j],dp[i][k]+dp[k+1][j]+sum_pre[j+1] - sum_pre[i])
        # print(i,j)
        # print_dp(dp)
print(dp[0][n-1])

