'''
題目意思 其實就是在求 湊成k的方案數
也就是說 題目給的n 要先 把集合的總和先算出來(目標)， k = (n*(1+n) / 2 )/ 2
然後我們要在 1 ~ n 裡湊出 k 有多少方案數 ，最後答案 要 除2  因為你求出一種 組合 必然也求得出另外一種組合，但
題目 把它 視為同一種。
1 ~ n 裡湊出 k 有多少方案數 
1 ~ n 裡湊出 k = (n+1)*n/2/2[題目要求] 有多少方案數 
先來聊聊 一般來說 我們可以怎麼想?
先給個例子好了， 1~4 k=5 例子小就好，因為概念是相通的
今天問題是 在湊出 5的組合數， 所以既然是這樣 每個數字 是不是有 兩種情況 選 和 不選，
我們來看看遇到這樣情況
假設我們先看 元素4 (1~4)，選 所以只剩 5 - 4 = 1，所以這時候你要解決的問題變成 湊成 1 有多少組合數
                      不選 所以只剩 5 - 0 = 5 ，這時候的問題變成 元素 1 ~ 3 湊成 5 的組合數
那記住 今天這兩種情況 是不是要把它們加起來? 因為都是組合數阿，所以
選   我們好像可以寫成  dp[i-j]     i:代表 要湊成的數。  j:代表 目前選重的數   那dp[i-j] :就代表 i-j 這個數的方案數
咦? 可是今天不選的情況下，會變成 當下這個數 不能選，而只能可慮其他元素，換句話說 就是 除了這個元素 其他元素湊成 i 的組合數
所以表示 之前 的元素 的狀態 是不要 保留起來，以備不時之需?
代表 我們可能要用 二維串列 來保存狀態，
選  dp[i-1][i-j]   第一個索引值代表 只有 前i-1項 所算出的組合數， 第二個索引值代表你要取的是 湊成多少的方案數
索引值  1     2   
不選 dp[i-1][j]    如上所述

如上面 我們是不是 可以很自然地寫出 dp[i][j] = dp[i-1][i-j] + dp[i-1][j]
再來就要去想 邊界 也就是 這個 式子的最初狀態 ，這個問題的最初問題 有就是 元素1 湊成1 顯然組合數是1，
所以 初始化 dp[1][1] = 1

那同學要理解 最好是 把過程推一遍

'''

n = int(input())
temp = int((1+n)*n/2/2)            #要湊的數字
dp = [[0]*(temp+1) for i in range(n+1)]      #

if n == 0:          #避免特殊情況
     print(0)
elif n == 1:        #避免特殊情況
     print(1)
elif (1+n)*n/2/2 != int((1+n)*n/2/2):        #當今天的 數字不是偶數時就錯了，因為題目要求 湊成的數字 要能分成兩種分法
     print(0)            #所以今天不是偶數 就印出0
else:
     dp[1][1] = 1    #初始化
     dp[1][0] = 1    
     for i in range(2,n+1):   #從2開始
          for j in range(0,temp+1):
               if j >=i:
                    dp[i][j] = dp[i-1][j] + dp[i-1][j-i]
               else:
                    dp[i][j] = dp[i-1][j]
        

     print(int(dp[-1][-1]/2))      #方案數 要除2